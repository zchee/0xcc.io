+++
date = "2017-06-14T16:50:25+09:00"
title = "A Manual for the Plan9 assembler"
+++

http://9p.io/sys/doc/asm.html

Rob Pike  
rob@plan9.bell-labs.com

Translated base by Google Translate

## Machines

MIPS、SPARC、Intel 386、AMD64、Power PC、およびARMのアセンブラがあります。68020アセンブラ `2a`（もはや配布されていません）は、最も古く、多くの点でプロトタイプです。  
アセンブラは、命令のオペランドの左から右への割り当て順序や、MOVEなどのマクロ命令の合成など 、多くのプロパティを共有して、マシンのロードとストアの構造の特質を隠すための単一のプログラムです。  
具体的には、このマニュアルの最初の部分は特に68020についてです。最後に、他のアセンブラの違いについての説明があります。 
このマニュアルの前提条件は、「Plan 9 Cコンパイラの使い方」（Rob Pike著）です。  

## Registers

アセンブラ内のすべての事前定義シンボルは大文字です。データ・レジスタは R0 ~ R7。アドレスレジスタは A0 ~ A7。浮動小数点レジスタは F0 ~ F7。  
A6のポインタは Cコンパイラによってデータを指すために使用され、短いアドレスをより頻繁に使用できるようにします。A6の値 は一定であり、Cプログラムの初期化中に外部定義シンボルa6baseのアドレスに設定する必要があり ます。  
以下のハードウェアレジスタがアセンブラで定義されています。それらの意味は、CAAR、 CACR、 CCR、 DFC、 ISP、 MSP、 SFC、 SR、 USP、および VBRの 68020マニュアルを使用して明らかにする必要があり ます。  
アセンブラはスタックを操作するいくつかの擬似レジスタFP、 SP、 TOSも定義し ます。 FP はフレームポインタなので、 0（FP） は第1引数、4（FP） は第2の引数など です。 SP はローカルスタックポインタで、自動変数が保持されます（SPは68020上の擬似レジスタです）。 0（SP） は最初の自動であり、FPと同様に続き ます。最後に、 TOS は、プロシージャへのパラメータのプッシュ、一時的な値の保存などに使用されるトップ・オブ・スタック・レジスタです。  
アセンブラとローダはこれらの擬似レジスタを追跡するため、A7が指すハードウェアスタックに何がプッシュされているかにかかわらず、上記の文は真です 。A7 という名前 はハードウェアスタックポインタを指しますが、A7 と上記のスタック関連疑似レジスタの混在に注意してください 。また、 PEA 命令はSPを変更するためにローダーによって観察されるため、すべてのリターンの前に対応するポップを挿入することにも注意してください。アセンブラは、ラベルのような名前が接続されるように受け入れ FP と SPは など、使用 のp + 0（FP）の文書を支援するために、 pは ルーチンへの最初の引数です。

## データ参照

すべての外部参照は、PC （バーチャルプログラムカウンタ）または SB （「スタティックベース」レジスタ）のいずれかの擬似レジスタに関連して行わなければなりません 。 PC カウント命令、データバイトではありません。例えば、第2の次の命令に分岐する、すなわち1つの命令をスキップするためには、

```asm
    BRA 2（PC）
```

ラベルも許可されています

```asm
    BRA return
    NOP
return：
    RTS
```

ラベルを使用する場合、（PC） 注釈はありません 。  
疑似レジスタ SB は、プログラムのアドレス空間の先頭を指します。このように、グローバルデータおよび手続きへの参照をへのオフセットとして書かれている SBのように、

```asm
    MOVL    $array(SB), TOS
```

スタック上のグローバル配列のアドレスをプッシュする

```asm
    MOVL    array+4(SB), TOS
```

配列の2番目の要素（4バイト）をプッシュします。オフセットの使用に注意してください。アドレッシングモードの完全なリストを以下に示します。同様に、サブルーチンコールではSBを使用する必要があります 。

```asm
    BSR exit(SB)
```

ファイル静的変数には構文があります

```asm
    local<>+4(SB)
```

<> 一意の整数で負荷時に入力されます。  
プログラムが起動すると、プログラムを実行する必要があります

```asm
    MOVL    $a6base(SB), A6
```

グローバルデータにアクセスする前に （MIPSとSPARCのような、単一の命令でレジスタをロードすることができないマシンでは、定数は静的なベース・レジスタを介してロードされ、ローダは静的なベース・レジスタを初期化して特別に扱うコードを認識しますが、  
静的ベースレジスタが設定されていないとき（割り込みルーチンの早い段階など）に、大きなマシンをロードしないようにします。

## 式

表現は主に予想されるものです。オフセットまたは定数が期待される場合、単項演算子を含む一次式が許可されます。一般的なC定数式はかっこで囲むことができます。  
ソースファイルはCコンパイラとまったく同じように前処理されるので、 `#define` と `#include`が 動作します。

## アドレッシングモード

シンプルなアドレッシングモードは、すべてのアセンブラで共有されます。ここでは、すべての68020アドレッシングモードのテーブルを完全に示すために、そのマシンが最も豊富なセットを持っているためです。表において、 o はオフセットであり、ゼロを省略することができ、 d は変位であり、-128と127との間の定数である。  
リストされているモードの多くは同じ名前です。フォーマットの精査は、デフォルトが適用されていることを示します。例えば、アドレスレジスタが供給されていないインデックス付きモードは、ゼロ値レジスタが使用されたかのように動作する。「オフセット」は「変位」を意味する。" .s "は、 .L、または .Wの 後に * 1、 * 2、 * 4 or 8.
  
## データの配置

疑似命令 LONG と WORD （ただしBYTEではなく ）は、命令のように、適切なサイズの単一引数の値を設定します。

```asm
    LONG    $12345
```

long 12345（基数10）を命令ストリームに配置します。（ほとんどのマシンでは、このような演算子は `WORD`であり、32ビットの数量を配置します.386には`LONG`、`WORD`、`BYTE`の3つがすべて含まれていますが、AMD64では 64ビット値の`QUAD`が追加さ れています。960  `LONG`。）  
情報をデータセクションに配置することは、より苦痛です。擬似命令`DATA`は、項目を配置するアドレス、サイズ、およびそこに配置する値の2つの引数を指定して、作業を行います。たとえば文字`abc`と終端`null`を含む文字配列配列を定義するには次のようにします。

```asm
    DATA    array+0(SB)/1, $’a’
    DATA    array+1(SB)/1, $’b’
    DATA    array+2(SB)/1, $’c’
    GLOBL   array(SB), $4
```

または

```asm
    DATA    array+0(SB)/4, $"abc\z"
    GLOBL   array(SB), $4
```

/1を 定義するバイト数を定義し、 GLOBLは、 シンボルがグローバルになり、そして $ 4は シンボルが占めているどのように多くのバイトを言います。初期化されていないデータは自動的にゼロになります。文字 \z はC \0に相当します。DATA 文の文字列には、最大8バイトを含めることができます。より大きな弦を断片的に作ります。2つの擬似命令DYNT と INITにより、ロードフェーズ中に（古くなった）Alefコンパイラが動的なタイプ情報を構築することができます。 DYNTの 擬似命令は、2つの形式があります。

```asm
    DYNT    , ALEF_SI_5+0(SB)
    DYNT    ALEF_AS+0(SB), ALEF_SI_5+0(SB)
```

最初の形式では、 DYNT はシンボルをローダーによって選択された小さな一意の整数定数と定義します。これはワードサイズの倍数です。2番目の形式では、 DYNT は同じ方法で2番目のシンボルを定義し、最後に定義されたテキストシンボルのアドレスを、2番目のシンボルの値で定義されたインデックスの最初のシンボルで指定された配列に配置し、それに応じてアレイの 
INITの 擬似命令は、同じパラメータを取り データ 声明。そのシンボルは配列のベースとして使用され、データ項目は最新のDYNT 擬似命令で指定されたオフセットで配列にインストールされ ます。それに応じて配列のサイズが調整されます。 DYNT と INIT 擬似命令は68020に実装されていません。

## プロシージャの定義

エントリポイントは、擬似操作TEXTによって定義されます。TEXT は、プロシージャの名前（ユビキタス （SB）を含む）とスタックに事前割り当てする自動ストレージのバイト数を引数としてとります。通常、アセンブリ言語プログラムの作成。MIPSやSPARCなどのリンク・レジスタを持つマシンでは、関数がリーフでなくても、特別な値-4はローダーに、PCのセーブとリストア命令を生成しないように指示します。以下に、2つの引数の合計を返す完全なプロシージャを示します。

```asm
TEXT    sum(SB), $0
    MOVL    arg1+0(FP), R0
    ADDL    arg2+4(FP), R0
    RTS
```

TEXT 疑似操作のオプションの中間引数 は、ローダーのオプションのビットフィールドです。1ビットを設定すると、残りのプログラムでプロファイリングが有効になっているときに関数のプロファイリングが中断されます。例えば、

```asm
TEXT    sum(SB), 1, $0
    MOVL    arg1+0(FP), R0
    ADDL    arg2+4(FP), R0
    RTS
```

プロファイルされません。上記の最初のバージョンがあります。システムコールルーチンなどの特殊な状態のサブルーチンは、プロファイリングしないでください。  
2ビットを設定する と、プログラム内で同じTEXTシンボルの複数の定義が可能になり ます。ローダはそのような機能を画像に1つだけ配置します。それはAlefコンパイラによってのみ生成されました。  
Cから呼び出されるサブルーチンは、アドレスであっても結果をR0に配置 する必要があります。浮動小数点値はF0で返され ます。構造体をCプログラムに返す関数は、最初の引数として結果を格納する場所のアドレスを受け取ります。 R0 は、そのような手順のための呼び出しプロトコルでは未使用です。サブルーチンは独自のレジスタを保存する責任があるため、レジスタを保存せずに自由に使用できます（ '' caller saves ''）。 A6 と A7 は上記の例外です。

## 疑わしいとき

混乱した場合は、-S オプションを使用して 2c を試し、サンプルプログラムをコンパイルしてみてください 。標準出力は、アセンブラへの有効な入力です。

## 指示

アセンブラの命令セットは、マシンの命令セットと同一ではありません。コンパイラが生成するものと一致するように選択され、オペレーティングシステムの特定のニーズによってわずかに拡張されます。たとえば、 2a はMOVE 命令のさまざまな形式を区別しません。move quick、move addressなどです。代わりにコンテキストがジョブを実行します。例えば、

```asm
    MOVL    $1, R1
    MOVL    A0, R2
    MOVW    SR, R3
```

公式の MOVEQ、 MOVEA、および MOVESR 命令が生成されます。多くの命令には、その機能全体を指定するのに必要な構文がありません。注目すべき例は、ビットフィールド命令、乗除算命令などです。生成された命令名の完全なセット（ Motorolaのものではなく2a表記）については、ファイル/sys/src/cmd/2c/2.out.hを参照してください 。その名前にもかかわらず、このファイルには、アセンブリ言語の行に正確に対応する、コンパイラによって生成された中間ファイルに表示される命令の列挙が含まれています。

## 命令を記述する

ローダは、アセンブラとコンパイラによって生成されたコードを変更します。分岐を折りたたみ、短いコードシーケンスをコピーして分岐をなくし、到達不能なコードを破棄します。すべての関数の最初の命令は到達可能であると仮定されます。コンパイラ出力に表示される擬似 命令NOPは、何もしない命令ではなく、命令をまったく意味しません。ローダはすべてのNOPを破棄し ます。  
真のNOP命令 またはアセンブラに知られていない他の命令を生成するに は、 WORD 擬似命令を使用します。RISCに関するそのような命令は、ローダによってスケジューリングされず、その遅延スロットを手動で満たさなければならない。

# MIPS

レジスタは、番号だけで対処されています。 R0 を通じて R31。 R29 はスタックポインタです。 R30 は 、68020上のA6のアナログであるスタティックベースポインタとして使用され ます。その値は、グローバルシンボルsetR30（SB）のアドレス です。サブルーチンから返された値を保持するレジスタは R1です。関数が呼び出されると、最初の引数のためのスペースは0（FP） で予約されます が、Cでは（Alef ではなく）R1の代わりに値が渡され ます。  
ローダーは R28 を一時的に使用します。システムは、R26 と R27 を割り込み時間の一時として使用し ます。したがって、これらのレジスタのどれもがユーザコードで使用されるべきではありません。  
制御レジスタはアセンブラに認識されません。代わりに、彼らは番号が付けられているレジスタ M0、 M1などは、アクセスにこのトリックを使用して、たとえば、

```asm
#define STATUS  12
    MOVW    M(STATUS), R1
```

浮動小数点レジスタが呼び出されます F0 を通じて F31。慣例により、 F24は 、値0.0に初期化されなければならない F26 、0.5〜 F28 1.0、及び F30 2.0。これはオペレーティングシステムによって行われます。  
指示書とその構文は製造元のマニュアルとは異なります。ルイ と親戚はいません 。代わりに、 MOVW （移動ワード）、 MOVH （移動ハーフワード）、および MOVB （移動バイト）疑似命令があります。オペランドが符号なしの場合、命令は MOVHU および MOVBUです。オペランドの順序は、68020と同様にデータフローの順序で左から右ですが、MIPSのマニュアルの順序とは異なります。これは、 Bcond 命令が本に対して逆転していることを意味します。例えば、 VA BGTZは MIPSの生成 BLTZの 命令。  
アセンブラは、R2000、R3000、およびほとんどのR4000アーキテクチャとR6000アーキテクチャ用です。これは、64ビット命令理解 MOVV、 MOVVL、 ADDV、 ADDVU、 SUBV、 SUBVU、 MuLVに、 MULVU、 DIVV、 DIVVU、 SLLV、 SRLV、及び SRAVを。アセンブラには、キャッシュ、ロードリンクまたはストア条件付き命令がありません。  
いくつかのアセンブラ命令は、ローダによって複数の命令に展開されます。例えば、ローダは、32ビット定数のロードをluiと それに続く oriに変換することができる 。  
アセンブラ命令は、ロード、ブランチ、または浮動小数点比較遅延スロットがないかのように配置する必要があります。ローダはrearrange-ますスケジュールを -the命令は正確さを保証し、パフォーマンスを向上させます。唯一の例外は、制御レジスタを使用する命令の正しいスケジューリングがモデルの機種によって異なります（そして文書化されていないことが多いため）。正しい動作を保証するために、手動でそのような命令をスケジュールする必要があります。ローダーは、

```asm
    NOR R0, R0, R0
```

真のノーオペレーション命令を必要とするとき。手動でコードをスケジュールする場合は、この命令を正確に使用してください。ローダはそれを認識し、その前と後に独立してコードをスケジュールします。また、 WORD 擬似操作はno-opsのようにスケジュールされます。  
NOSCHED 擬似オペコードは、（スケジューリングがデフォルトで有効になって）命令スケジューリングを無効にします。 SCHED はそれを再び有効にする。ブランチフォールディング、コードコピー、およびデッドコード消去は、スケジュールされていない命令では無効になります。

## SPARC

MIPSのPlan 9モデルを理解すると、SPARCは使い慣れたものになります。レジスタは、数値の名前を持つ： R0 を通じて R31。レジスタウィンドウは忘れてください：Plan 9はそれらをまったく使用しません。マシンには32個のグローバルレジスタperiodがあります。 R1 [sic]はスタックポインタです。 R2 はスタティックベースレジスタで、値はsetSB（SB）のアドレス です。 R7 は戻りレジスタであり、最初の引数をC（Alefではない）関数に保持するレジスタでもあり、領域は0（FP）で予約されてい ます。 R14 は一時的なローダーです。  
浮動小数点レジスタは、MIPSとまったく同じです。  
制御レジスタは、FSRなどの名前で知られています 。これらのレジスタにアクセスする命令は 、例えばMOVW命令である

```asm
    MOVW    Y, R8
```

SPARC命令の場合

```asm
    rdy %r8
```

移動命令は、適切なシーケンスのsethi 命令、加算命令などに変わるMIPS：擬似演算の命令に似ています 。命令は左から右に読み込まれます。引数はSUBCCに反転さ れるので、条件コードはMIPSのように反転しません。  
ASI用の構文は、たとえばASI 2から単語を移動する場合です。

```asm
    MOVW    (R7, 2), R8
```

二重インデックスの構文は次のとおりです。

```asm
    MOVW    (R7+R8), R9
```

SPARCの命令スケジューリングは、MIPSに似ています。公式のノーオペレーションの指示は：

```asm
    ORN R0, R0, R0
```

## i960

レジスタは、番号が付けられている R0を 経由 R31。スタックポインタは R29です。戻りレジスタは R4です。スタティックベースは R28です。setSB（SB）のアドレスに 初期化されます。 R3 はゼロでなければなりません。これは、実行の早い段階で手動で行う必要があります。

```asm
    SUBO R3、R3
```

R27 は一時的なローダーです。  
浮動小数点のサポートはありません。  
インテルの呼び出し規約はサポートされておらず、使用できません。使用 BALを 代わりに。説明は主に本の通りです。主な変更点は、 LOAD と STORE の両方がMOVと呼ばれること です。MOVの拡張文字は マニュアルのとおりです： 序数は O 、符号付きはWなど

## i386

アセンブラは32ビット保護モードを想定しています。レジスタ名は SP、 AX、 BX、 CX、 DX、 BP、 DI、 SIです。スタックポインタ（疑似レジスタではない）は SPで あり、戻りレジスタは AXです。物理的なフレームポインタはありませんが、MIPSに関しては、 FP はフレームポインタとして機能する疑似レジスタです。  
オペコード名は、インテルのマニュアルに記載されているものとほとんど同じですが、 32ビット、16ビット、および8ビットのオペレーションを識別するためにL、 W、または Bが付加されています。例外は、ロード、ストア、および条件です。汎用レジスタ、特殊レジスタ（CR0、CR3、GDTR、IDTR、SS、CS、DS、ES、FS、 およびGSなど）またはメモリと のロードおよびストアのオペコードはすべて、

```asm
    MOVx    src,dst
```

ここで、 xは ある L、 W、または B。したがって、ALを取得 するには MOVB 命令を使用します。AHにアクセスする必要がある場合は、MOVBで明示的に言及する必要があります。

```asm
    MOVB AH, BX
```

違法移動の例はたくさんあります。たとえば、

```asm
    MOVB BP, DI
```

ローダーが実際に疑似操作として実装されていることを示します。  
すべての条件付き命令における条件の名前（J、 SETは）代わりに、インテルのアセンブラのこれらの68020の規則に従う： JOS、 JOC、 JCS、 JCC、 JEQ、 JNE、 JLS、 JHI、 JMI、 JPL、 JPS、 JPC、 JLT、 JGE、 JLE、 JGTの 代わりに JO、 JNO、 JB、 JNB、 JZ、 JNZ、 JBE、 JNBE、 JS、 JNS、 JP、 JNP、 JL、 JNL、 JLE、および JNLEが含まれます。  
アドレッシングモードは、AX、 （AX）、 （AX）（BX * 4）、 10（AX）、および 10（AX）（BX * 4）のような構文を持ちます 。AXからの オフセットはFP または SB からextern + 5（SB）（AX * 2）などのアクセス名への オフセットで置き換えることができ ます。  
その他の注記：非相対 JMP および CALLに は 構文に*が追加されています。のみ LOOP、 LOOPEQ、および LOOPNEは 法的なループ命令です。のみ REP と REPNは リピーターを認識しています。これらはプレフィックスではなく、文字列に先行するスタンドアロンのオペコードです（例：

```asm
    CLD; REP; MOVSL
```

MOD / RM フィールドのセグメントオーバーライドプレフィックスはサポートされていません。

## AMD64

アセンブラは、MODE 疑似演算が指定されていない限り、64ビットモードを想定しています。

```asm
    MODE $32
```

32ビットモードに変更します。その効果は、主に、指定されたモードでは不正な命令を診断することですが、ローダーは32ビットのオペランドとアドレス、および呼び出しと戻りのための32ビットのPC値も想定します。アセンブラの規則は、上記の386の規則に類似しています。アーキテクチャは、余分な固定小数点レジスタ提供 R8を する R15。すべてのレジスタは64ビットですが、命令はプロセッサハンドブックに記載されているように低位8,16および32ビットにアクセスします。たとえば、 MOVL と AX は、下位32ビットに値を置き、上位32ビットをゼロにクリアします。リテラルオペランドは符号付き32ビット値に限定され、64ビット演算で64ビットに符号拡張されます。例外は MOVQで、これは64ビットのリテラルを許可します。  
MMXおよびXMMメディア命令、条件付き移動命令など、多くの新しい命令があります。MMXレジスタはある M0 に M7、およびXMMレジスタがある X0 に X15。386命令の命名と同様に、すべての新しい64ビット整数命令およびMMX命令およびXMM命令 は、 'ロングワード'（32ビット）にはLを 使用し 、 'クワッドワード'（64ビット）にはQを一律に使用し ます。命令の中には 、128ビット値にO（ 'octword'）を使用するものがあります。プロセッサハンドブックでは、O または DQをさまざまに使用し ます。アセンブラはまた、一貫して使用して PLを 代わりに、XMM命令で「長い詰め」の Q、 DQ または PI。 レジスタが64ビットであっても、MOVL または MOVQのいずれか を使用して、制御レジスタとの間で値を移動することができます。アセンブラでは、既存のコードの変換を容易にするためにハンドブックの名前を受け入れることがよくあります（ただし、オペランドの順序は一様なソースとデスティネーションです）。  
Cの ロング・ロング・ タイプは64ビットですが、参照渡しではなく値渡しで戻されます。特に、Cのポインタ値は64ビットであるため、 long long と unsigned long long は、ポインタ値を保持するのに十分な唯一の整数型です。後者はアセンブラとローダで実装されますが、CコンパイラとライブラリはXMM浮動小数点命令を使用しますが、古い387命令は使用しません。386とは異なり、最初の整数またはポインタ引数はレジスタに渡されます。これは 整数またはポインタのBPです（アセンブリコードでは仮名 RARGで参照できます）。 AX は以前のようにサブルーチンからの戻り値を保持します。 浮動小数点結果はX0で返されますが、現在、最初の浮動小数点パラメータはレジスタに渡されません。長さが8バイト未満のすべてのパラメータは、バイト4〜7は初期化されていなくても、レジスタに渡されたときの最初のパラメータを含む可変長引数リストへのアクセスを簡素化し、整列を保持するためにスタック上に8バイトスロットが予約されています。

## Power PC

Power PCは、精巧なABIではなく、MIPSとSPARCによって設定されたPlan 9モデルに従います。60xおよび8xx PowerPCアーキテクチャーの32ビット命令がサポートされています。古いPOWER命令はサポートされていません。レジスタは R0 て R31。 R0 はゼロに初期化される。これはCスタートアップコードによって行われ、コンパイラとローダによって引き継がれます。 R1 はスタックポインタです。 R2 はスタティックベースレジスタで、値はsetSB（SB）のアドレス です。 R3 は戻りレジスタであり 、MIPSのように0（FP）で確保されたスペースを持つC関数への最初の引数を保持するレジスタ です。 R31 は一時的なローダーです。  
浮動小数点レジスタが呼び出されます F0 を通じて F31。慣例により、いくつかのレジスタは特定の値に初期化されます。これはオペレーティングシステムによって行われます。 F27 は 0x4330000080000000 （浮動小数点からintへの変換で使用されます）、 F28 から0.0、 F29 から0.5、 F30 から1.0、および F31 から2.0の値に初期化する必要があります。  
MIPSとSPARC上など、アセンブラにオペランドとして任意のリテラル受け入れ MOVWを、とも ADD および「即時」変異体が存在し、ローダの配列を生成する他の ADDI、 アディス、 オリス必要に応じて等、。レジスタ間接アドレッシングモードでは、SPARCと同じ構文を使用します。  
命令名は一般的にモトローラのものから派生しています。条件コードの設定をマークすることはCCに置き換えられ 、文字「o」が「OE = 1」を表すとき、それはVに置き換えられる 。このように 追加し、 アッドを。 そして subfzeo。 となっ ADD、 ADDVCC と SUBFZEVCC。アセンブラは、3オペランド条件分岐命令 BCと同様に、一般的なケースのための疑似命令を提供します： BEQ、 BNE、 BGT、 BGE、 BLT、 BLE、 BVC、および BVS。無条件分岐命令は BRです。間接支店は 、ターゲットとして（CTR） または （LR）を使用します。  
ロードまたはストア動作がで置き換えられている MOVの ：通常の方法で変異体 MOVW （移動ワード）、 MOVH （符号拡張とハーフワード移動）、及び MOVB 符号なしバリアントと（符号拡張、疑似命令と移動バイト）、 MOVHZ と MOVBZ、およびバイト反転 MOVWBR および MOVHBRがあります。'アップデートをロードまたはストアする'バージョンは MOVWU、 MOVHU、および MOVBZUです。複数のロードまたはストアは MOVMWです。例外はあるストリング命令、ある LSW と STSW、 および予約命令lwarx および stwcxを含む。、である LWAR と STWCCC通常のデータフローのために、すべてのオペランドを有します。浮動小数点ロード命令またはストア命令は、 FMOVD、 FMOVDU、 FMOVS、およびFMOVSUです。登録するレジスタfmr とfmrを登録します。FMOVD とFMOVDCC と書かれています。FMOVS、およびFMOVSU。登録するレジスタfmrとfmrを登録します。FMOVDとFMOVDCCと書かれています。FMOVS、および FMOVSU。登録するレジスタfmrと fmrを登録し ます。FMOVDとFMOVDCCと書かれ て います。  
アセンブラは、CR、 CTR、 DEC、 LR、 MSR、および XERのような汎用レジスタを認識し ます。アーキテクチャに依存することが多い残りの部分は、 SPR（n）として参照されます。60xシリーズのセグメント レジスタも同様にSEG（n）ですが、 nはSEG（R3）のようにレジスタ名にすることもでき ます。専用レジスタと汎用レジスタとの間の移動は、アーキテクチャによって許可されている場合はMOVWと 書かれ、 mfcr、 mtcr、 mfmsr、 mtmsr、 mtspr、  
状態レジスタのフィールド CRは として参照されている CR（0） を介して、 CR（7） 。これらは 、mcrf または mtcrfを生成するMOVFL（移動フィールド）擬似 命令によって使用され ます。例えば：

```asm
    MOVFL   CR(3), CR(0)
    MOVFL   R3, CR(1)
    MOVFL   R3, $7, CR  
```

それらは条件付き分岐命令でも受け入れられます。

```asm
    BEQ CR(7), label
```

同様に、MOVFL を使用してFPSCRのフィールドにアクセスします。

```asm
    MOVFL   FPSCR, F0
    MOVFL   F0, FPSCR
    MOVFL   F0, $7, FPSCR
    MOVFL   $0, FPSCR(3)
```

生産 mffs、 mtfsf または mtfsfi必要に応じて、。

## ARM

アセンブラはへのアクセスを提供 R0を 通過 R14 および PC。スタックポインタは R13、リンクレジスタは R14、スタティックベースレジスタは R12です。 R0 は戻りレジスタであり、サブルーチンへの最初の引数を保持するレジスタです。Plan 9のCの外部レジスタはR10から割り付けられ ます。 R11 はローダーによって一時レジスタとして使用されます。アセンブラはCPSR および SPSRレジスタをサポートしてい ます 。また、登録したコプロセッサを知っている C0を 経由 C15。  
他のアーキテクチャと同様に、ロードとストアはMOVと呼ばれます 。たとえば 、ロード・ワードまたはストア・ワードの場合は MOVW 、オペランドに応じてロードまたはストアの場合はMOVMです。  
アドレッシングモードは、命令に接尾辞によってサポートされています .IA （インクリメント後）、 .IB （インクリメント前）、 .DA （デクリメント後）、および .DB （デクリメント前）。これらは、MOV 命令でのみ使用できます。複数移動命令MOVMは、括弧を使用してレジスタの範囲を定義します（例： [R0-R12]）。特殊な MOVM アドレッシングモードビット W、 U、 P は、MOVM.DB.Wのように同じ方法で書き込まれ ます。 。 S サフィックスを使用する と、別のプロセッサーモードのときにMOVM 命令がユーザーR13 および R14にアクセスできるように なります。アドレッシングモードでのシフトとローテーションは、バイナリ演算子 << （論理左シフト） >> （論理右シフト）、- > （算術右シフト）、および@> （右回転）でサポートされます。例えばR7 >> R2またはR2→2である。アセンブラは、シフトされた式による索引付けをサポートしていません。名前だけを二重に索引付けすることができます。（論理右シフト）、- >（算術右シフト）、および@>（右回転）例えばR7 >> R2またはR2→2である。アセンブラは、シフトされた式による索引付けをサポートしていません。名前だけを二重に索引付けすることができます。（論理右シフト）、 - >（算術右シフト）、および @>（右回転）例えば R7 >> R2または R2→2である。アセンブラは、シフトされた式による索引付けをサポートしていません。名前だけを二重に索引付けすることができます。  
任意の命令は、命令が条件なるサフィックスが続くことができる： .EQ、 .NEなど、ARMマニュアルのように、同義語と .HS （用 .CS）と .LO （用 .CCを）、たとえば ADD.NE。算術演算命令と論理 命令には、ARMが許すように条件コードを設定するための.S接尾辞を付けることが できます。  
MCR コプロセッサ命令 と MRCコプロセッサ命令の構文は、 主にマニュアルのとおりであり、通常の調整が行われます。アセンブラは、CMP、 ADD、 SUB、 MUL、および DIVのすべての F または D 接尾辞が単精度または倍精度を選択しているARM浮動小数点コプロセッサ演算のみを直接サポートし ます。浮動小数点ロードまたはストアは MOVF および MOVDになります。変換命令は、 MOVWD、 MOVWF、 MOVDW、 MOVWD、 MOVFD、
